#!/bin/bash
#-------------------------------------------------------------------------------
# slackrepo - Automated SlackBuilding from git repo into package repo,
#             for more details see /usr/doc/slackrepo-*/HOWTO
#
# Copyright 2014 David Spencer, Baildon, West Yorkshire, U.K.
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#-------------------------------------------------------------------------------

function print_usage
{
  echo 'Usage:'
  echo "  $(basename $0) build   [--control_args] [item...]"
  echo "  $(basename $0) rebuild [--control_args] [item...]"
  echo "  $(basename $0) update  [--control_args] [item...]"
  echo "  $(basename $0) remove  [--control_args] item..."
  echo 'Control args:'
  echo '  --verbose | --quiet'
  echo '  --repo=ID'
  echo '  --test'
  echo '  --dry-run'
  echo '  --keep-tmp'
  return
}

#-------------------------------------------------------------------------------

function exit_cleanup
{
  rm -f "$PIDFILE"
}

#-------------------------------------------------------------------------------

[ $# = 0 ] && { print_usage; exit_cleanup; exit 0; }

starttime=$(date +%s)

#-------------------------------------------------------------------------------
# Mode and control args
#-------------------------------------------------------------------------------

PROCMODE=''
OPT_TEST='n'
OPT_DRYRUN='n'
OPT_VERBOSE='n'
OPT_QUIET='n'
OPT_KEEPTMP='n'

while [ $# != 0 ]; do
  case "$1" in
    # we'll accept build/rebuild/update/remove with or without '--'
    build | --build )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='build'
      shift; continue ;;
    rebuild | --rebuild )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='rebuild'
      shift; continue ;;
    update | --update )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='update'
      shift; continue ;;
    remove | --remove )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='remove'
      shift; continue ;;
    --repo=* )
      SR_REPO=$(echo "$1" | sed 's/^--repo=//')
      shift; continue ;;
    --verbose | -v )
      OPT_VERBOSE='y'; OPT_QUIET='n'
      shift; continue ;;
    --quiet | -q )
      OPT_QUIET='y'; OPT_VERBOSE='n'
      shift; continue ;;
    --test )
      OPT_TEST='y'
      shift; continue ;;
    --dry-run )
      OPT_DRYRUN='y'
      shift; continue ;;
    --keep-tmp )
      OPT_KEEPTMP='y'
      shift; continue ;;
    --* )
      print_usage; exit_cleanup; exit 3 ;;
    * )
      break ;;
  esac
done

[ -z "$PROCMODE" ] && \
  { print_usage; exit_cleanup; exit 3; }

#-------------------------------------------------------------------------------
# Startup
#-------------------------------------------------------------------------------

PIDFILE="/var/run/$(basename $0).pid"
oldpid=$(cat "$PIDFILE" 2>/dev/null)
if [ -z "$oldpid" -o -z "$(pgrep -u root $(basename $0) | grep -v $$)" ]; then
  echo $$ > "$PIDFILE"
else
  echo "$(basename $0): Another instance is already running." >&2
  exit_cleanup
  exit 3
fi

# Ensure ctrl-c (etc) exits the whole thing, not just a random subshell
trap "exit_cleanup; exit 1" SIGINT SIGQUIT SIGTERM

# Get the support functions
for f in /usr/libexec/$(basename $0)/functions.d/*.sh; do
  if [ -x "$f" ]; then
    . "$f"
  fi
done

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------

# Set the repo ID from control arg, or env...
SR_REPO="${SR_REPO:-$REPO}"
# ... or just fall back to hardcoded SBo.
[ -z "${SR_REPO:=$REPO}" ] && SR_REPO="SBo"

# Set config variables from environment:
varnames="SBREPO PKGREPO SRCREPO \
          HINTS LOGDIR TMP \
          ARCH TAG PKGTYPE NUMJOBS USE_GENREPOS \
          INIT_GITCLONE INIT_GITBRANCH"
# We'll prefix all these with SR_ to stop SlackBuilds picking them up
for envvar in $varnames ; do
  myvar="SR_$envvar"
  eval $myvar="${!envvar}"
done
# Read the config files:
repoconf="/etc/slackrepo/slackrepo_${SR_REPO}.conf"
if [ -f "$repoconf" ]; then
  . "$repoconf"
else
  echo "Error: repo configuration file not found: $repoconf"; exit_cleanup; exit 2
fi
userconf="~/.slackreporc"
if [ -f "$userconf" ]; then
  . "$userconf"
fi
# Backfill the SR_ variables from config and unset the config variables
for confvar in $varnames ; do
  myvar="SR_$confvar"
  [ -z "${!myvar}" ] && eval $myvar=\"${!confvar}\"
  eval unset $confvar
done

# Do this early so we can log the config:
mkdir -p "$SR_LOGDIR"
MAINLOG="$SR_LOGDIR"/$(basename $0)_$(date '+%F_%T').log
> "$MAINLOG"

# If SR_NUMJOBS or SR_ARCH not set, work them out and set them explicitly
if [ -z "$SR_NUMJOBS" ]; then
  SR_NUMJOBS="-j$(( $(nproc) + 1 ))"
fi
# setting ARCH breaks lots of SlackBuilds, which is why we do it ;-)
if [ -z "$SR_ARCH" ]; then
  case "$( uname -m )" in
    i?86) SR_ARCH=i486 ;;
    arm*) SR_ARCH=arm ;;
       *) SR_ARCH=$( uname -m ) ;;
  esac
fi

# Find out the version of Slackware
# (used by the git stuff below, but we also need this in revfunctions.sh)
[ -f /etc/slackware-version ] || { log_error "/etc/slackware-version not found"; exit_cleanup; exit 4; }
SLACKVER="$(cat /etc/slackware-version | sed 's/^Slackware //')"

# Log the config
[ "$OPT_VERBOSE" = 'y' ] && echo ""
log_verbose "Configuration:"
[ "$OPT_VERBOSE" = 'y' ] && log_verbose "  --verbose"
[ "$OPT_QUIET" = 'y'   ] && log_verbose "  --quiet"
log_verbose "  --repo=$SR_REPO"
log_verbose "  --$PROCMODE"
[ "$OPT_DRYRUN" = 'y'  ] && log_verbose "  --dry-run"
[ "$OPT_TEST" = 'y'    ] && log_verbose "  --test"
[ "$OPT_KEEPTMP" = 'y' ] && log_verbose "  --keep-tmp"
for var in $varnames; do
  myvar="SR_$var"
  log_verbose "  $var='${!myvar}'"
done
[ "$OPT_VERBOSE" = 'y' ] && echo ""

#-------------------------------------------------------------------------------
# Initialisation
#-------------------------------------------------------------------------------

# Arrays for tracking build outcomes:
declare -a OKLIST SKIPPEDLIST FAILEDLIST ABORTEDLIST

# Temporary directory:
SR_TMP=${SR_TMP:-/tmp/SBo}
# really really don't want the next bit to go badly ;-)
if [ -n "$SR_TMP" -a -d "$SR_TMP" -a "$OPT_KEEPTMP" != 'y' ]; then
  log_normal "Removing $SR_TMP/* ..."
  rm -rf "${SR_TMP:-dont-tase-me-bro}"/*
else
  mkdir -p $SR_TMP
fi

# Use the standard Unix TMPDIR for things that SR_TMP wouldn't be good for
# (SR_TMP gets cleaned during execution)
TMPDIR=${TMPDIR:-/tmp}

# Changelog:
TMP_CHANGELOG="$TMPDIR"/sr_changelog_"$SR_REPO".tmp
if [ -s "$TMP_CHANGELOG" ]; then
  log_normal "Continuing changelog $TMP_CHANGELOG from previous run."
else
  > "$TMP_CHANGELOG"
fi

# Disposable package repository for dry run:
if [ "$OPT_DRYRUN" = 'y' ]; then
  DRYREPO="$SR_TMP"/sr_DRY.$$
  rm -rf "$DRYREPO"
  mkdir -p "$DRYREPO"
fi

# Create directories:
[ -d "$SR_SBREPO" ]  || { log_normal "Creating SlackBuild repository: $SR_SBREPO" ; mkdir -p "$SR_SBREPO"  ; }
[ -d "$SR_SRCREPO" ] || { log_normal "Creating source repository: $SR_SRCREPO"    ; mkdir -p "$SR_SRCREPO" ; }
[ -d "$SR_PKGREPO" ] || { log_normal "Creating package repository: $SR_PKGREPO"   ; mkdir -p "$SR_PKGREPO" ; }
[ -d "$SR_LOGDIR" ]  || { log_normal "Creating log directory: $SR_LOGDIR"         ; mkdir -p "$SR_LOGDIR"  ; }
[ -d "$SR_HINTS" ]   || { log_normal "Creating hints directory: $SR_HINTS"        ; mkdir -p "$SR_HINTS"   ; }

# git stuff for the SlackBuilds repo:
if [ -z "$(ls "$SR_SBREPO" 2>/dev/null)" ]; then
  if [ -n "${SR_INIT_GITCLONE}" ]; then
    log_normal "Cloning SlackBuilds repository $SR_SBREPO from ${SR_INIT_GITCLONE} ..."
    git clone "${SR_INIT_GITCLONE}" "$SR_SBREPO"
    cd "$SR_SBREPO"
    git fetch -a
    git remote update
    branch="${SR_INIT_GITBRANCH:-$SLACKVER}"
    git checkout -b "$branch" -t origin/"$branch"
    log_normal "Finished cloning SlackBuilds repository."
  fi
elif [ -d $SR_SBREPO/.git ]; then
  cd $SR_SBREPO
  # Is git clean, and is the branch SBo's stable branch?
  log_normal "Checking git ..."
  muck="$(git status -s .)"
  branch=$(git rev-parse --abbrev-ref HEAD)
  if [ -z "$muck" -a "$branch" = "$SLACKVER" ]; then
    if [ -n "$(find "$SR_SBREPO"/.git/FETCH_HEAD -mtime +1 2>/dev/null)" ]; then
      log_normal "Updating git ..."
      if [ "$OPT_QUIET" = 'y' ]; then
        git fetch -a                         >> "$MAINLOG" 2>&1
        git merge --ff-only origin/"$branch" >> "$MAINLOG" 2>&1
      else
        git fetch -a                         2>&1 | tee -a "$MAINLOG"
        git merge --ff-only origin/"$branch" 2>&1 | tee -a "$MAINLOG"
      fi
      log_normal "Finished updating git."
    fi
  fi
fi

# git: log a summary
GOTGIT='n'
if [ -d "$SR_SBREPO"/.git ]; then
  GOTGIT='y'
  [ "$OPT_VERBOSE" = 'y' ] && echo ""
  log_verbose "Git repo:   $SR_SBREPO"
  log_verbose "  branch:   $(git rev-parse --abbrev-ref HEAD)"
  log_verbose "  revision: $(git rev-parse HEAD)"
  log_verbose "  title:    $(git log -n 1 --format=%s)"
  if [ -n "$(cd $SR_SBREPO; git status -s .)" ]; then
    log_warning "Git repository $SR_SBREPO is dirty"
  fi
  [ "$OPT_VERBOSE" = 'y' ] && echo ""
fi

# Warn about already installed packages (using package tag)
if [ -n "$SR_TAG" ]; then
  installed=$(ls /var/log/packages/*"$SR_TAG" 2>/dev/null)
  if [ -n "$installed" ]; then
    for pkg in $installed; do
      # don't moan if it has a no_uninstall hint
      pkgnam=$(basename $pkg | rev | cut -f4- -d- | rev)
      if [ -z "$(find $SR_HINTS -name $pkgnam.no_uninstall)" ]; then
        log_warning "$(basename $pkg): package is already installed"
      fi
    done
  fi
fi

# Command arguments:
if [ $# = 0 ]; then
  if [ "$PROCMODE" = 'remove' ]; then
    # remove mode with no args => do nothing
    echo "Usage: $(basename $0) remove [--repo=ID] item..."
    echo "In remove mode, you *must* specify the items to be removed."
    exit_cleanup
    exit 3
  elif [ "$PROCMODE" = 'update' ]; then
    # update mode with no args => process everything in the package repo
    set -- "$SR_PKGREPO"
  else
    # other modes with no args => process everything in the SlackBuilds repo
    set -- "$SR_SBREPO"
  fi
fi

#-------------------------------------------------------------------------------
# Main loop
#-------------------------------------------------------------------------------

BLAME="$(basename $0)"
while [ $# != 0 ]; do
  item="$1"
  shift
  if [ "$PROCMODE" = 'build' -o "$PROCMODE" = 'rebuild' ]; then
    parse_items -s "$item"
  else # 'update' or 'remove'
    parse_items -p "$item"
  fi
  # Note that we set the variable $ITEMID (upper case) so that other functions
  # called recursively (which get $itemid as an argument) can test whether they
  # are dealing with the top level item.
  for ITEMID in "${ITEMLIST[@]}"; do
    echo ""
    log_start "$ITEMID"
    case "$PROCMODE" in
    'build' | 'rebuild' )
      build_with_deps "$ITEMID"
      ;;
    'update' )
      itemdir="${ITEMDIR[$ITEMID]}"
      if [ -d "$SR_SBREPO"/"$itemdir"/ ]; then
        build_with_deps "$ITEMID"
      else
        remove_item "$ITEMID"
      fi
      ;;
    'remove' )
      remove_item "$ITEMID"
      ;;
    *)
      log_error "$(basename $0): Unrecognised PROCMODE = $PROCMODE"
      exit 4
      ;;
    esac
  done
done

#-------------------------------------------------------------------------------
# Print a summary of what happened
#-------------------------------------------------------------------------------

echo ""
echo "==============================================================================="
echo "! SUMMARY                                                            $(date +%T) !"
echo "==============================================================================="
echo ""
secs=$(( $(date +%s) - $starttime ))
h=$(( $secs / 3600 )); m=$(( ( $secs / 60) % 60 )); s=$(( $secs % 60 ))
echo "Time:       ${h}h ${m}m ${s}s"
echo "Processed:  $(( ${#OKLIST[@]} + ${#SKIPPEDLIST[@]} + ${#FAILEDLIST[@]} + ${#ABORTEDLIST[@]} ))"

if [ "$OPT_DRYRUN" = 'y' ]; then
  OKLIST=( $(printf '%s\n' "${OKLIST[@]}" | sort -u) )
  okcount="${#OKLIST[@]}"
  echo "Dry run OK: $okcount"
  [ "$OPT_QUIET" != 'y' -a "$okcount" != 0 ] && printf '  %s\n' "${OKLIST[@]}"
else
  echo "Added:      $(grep ': Added'   "$TMP_CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Added'   "$TMP_CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort
  echo "Updated:    $(grep ': Updated' "$TMP_CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Updated' "$TMP_CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort
  echo "Rebuilt:    $(grep ': Rebuilt' "$TMP_CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Rebuilt' "$TMP_CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort
  echo "Removed:    $(grep ': Removed' "$TMP_CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Removed' "$TMP_CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort
fi
SKIPPEDLIST=( $(printf '%s\n' "${SKIPPEDLIST[@]}" | sort -u) )
skippedcount="${#SKIPPEDLIST[@]}"
echo "Skipped:    $skippedcount"
[ "$OPT_QUIET" != 'y' -a "$skippedcount" != 0 ] && printf '  %s\n' "${SKIPPEDLIST[@]}"
FAILEDLIST=( $(printf '%s\n' "${FAILEDLIST[@]}" | sort -u) )
failedcount="${#FAILEDLIST[@]}"
echo "Failed:     $failedcount"
[ "$OPT_QUIET" != 'y' -a "$failedcount" != 0 ]  && printf '  %s\n' "${FAILEDLIST[@]}"
ABORTEDLIST=( $(printf '%s\n' "${ABORTEDLIST[@]}" | sort -u) )
abortedcount="${#ABORTEDLIST[@]}"
echo "Aborted:    $abortedcount"
[ "$OPT_QUIET" != 'y' -a "$abortedcount" != 0 ] && printf '  %s\n' "${ABORTEDLIST[@]}"
warncount=$(grep '^WARNING: ' "$MAINLOG" | wc -l)
echo "Warnings:   $warncount"
[ "$OPT_QUIET" != 'y' ] && grep '^WARNING: ' "$MAINLOG" | sed 's/^WARNING: /  /'

#-------------------------------------------------------------------------------
# Package repository maintenance: gen_repos_files.sh
#-------------------------------------------------------------------------------

genrepstat=0
if [ "$OPT_DRYRUN" != 'y' -a -s "$TMP_CHANGELOG" ]; then
  rcfile=~/.genreprc
  [ -f "$rcfile" ] && { set -e; . "$rcfile"; set +e; }
  if [ "$SR_USE_GENREPOS" = 1 ]; then
    echo ""
    log_start "gen_repos_files.sh"
    # 'man sort' says an in-place sort is ok, so let's be lazy :-)
    sort -o "$TMP_CHANGELOG" "$TMP_CHANGELOG"
    if [ "$RSS_UUID" = '' ]; then
      setrssuuid="RSS_UUID=\"$(uuidgen -t)\""
      log_normal "Note: setting $setrssuuid in $rcfile"
      echo "$setrssuuid" >> "$rcfile"
      eval $setrssuuid
    fi
    REPOSROOT="$REPOSROOT" REPOSOWNER="$REPOSOWNER" REPOSOWNERGPG="$REPOSOWNERGPG" DL_URL="$DL_URL" \
    RSS_TITLE="$RSS_TITLE" RSS_ICON="$RSS_ICON" RSS_LINK="$RSS_LINK" RSS_CLURL="$RSS_CLURL" \
    RSS_DESCRIPTION="$RSS_DESCRIPTION" RSS_FEEDMAX="$RSS_FEEDMAX" RSS_UUID="$RSS_UUID" \
    GPGBIN="$GPGBIN" USE_GPGAGENT="$USE_GPGAGENT" FOR_SLAPTGET="$FOR_SLAPTGET" \
    FOLLOW_SYMLINKS="$FOLLOW_SYMLINKS" REPO_SUBDIRS="$REPO_SUBDIRS" \
    sh /usr/libexec/$(basename $0)/gen_repos_files.sh -l "$TMP_CHANGELOG" | tee -a "$MAINLOG"
    genrepstat=$?
    [ "$genrepstat" != 0 ] && log_error "gen_repos_files.sh failed -- changelog retained"
    echo ""
    log_important "Finished gen_repos_files.sh at $(date +%T)"
  fi
fi

#-------------------------------------------------------------------------------

echo ""

[ "$genrepstat" = 0 -a "$OPT_KEEPTMP" != 'y' ] && rm -f "$TMP_CHANGELOG"
[ "$OPT_KEEPTMP" != 'y' ] && rm -rf "$DRYREPO"
exit_cleanup

exit 0
