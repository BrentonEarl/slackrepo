#!/bin/bash
#-------------------------------------------------------------------------------
# slackrepo - Automated SlackBuilding from git repo into package repo,
#             for more details see /usr/doc/slackrepo-*/HOWTO
#
# Copyright 2014 David Spencer, Baildon, West Yorkshire, U.K.
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#-------------------------------------------------------------------------------

function print_usage
{
  echo 'Usage:'
  echo "  $(basename $0) build   [--control_args] [item...]"
  echo "  $(basename $0) rebuild [--control_args] [item...]"
  echo "  $(basename $0) update  [--control_args] [item...]"
  echo "  $(basename $0) remove  [--control_args] item..."
  echo 'Control args:'
  echo '  --repo=ID'
  echo '  --quiet | --verbose | --very-verbose'
  echo '  --test'
  echo '  --dry-run | --install'
  echo '  --keep-tmp'
  return
}

#-------------------------------------------------------------------------------

function exit_cleanup
{
  rm -f "$PIDFILE"
  [ "$OPT_KEEP_TMP" != 'y' -a -n "$MYTMPDIR" ] && rm -rf "$MYTMPDIR"
}

#-------------------------------------------------------------------------------

[ $# = 0 ] && { print_usage; exit_cleanup; exit 0; }

starttime=$(date +%s)

#-------------------------------------------------------------------------------
# Mode and control args
#-------------------------------------------------------------------------------

# General rule:
# OPT_XXXX represents command line option XXXX
# SR_XXXX represents config file variable XXXX

optnames="REPO QUIET VERBOSE VERY_VERBOSE TEST DRY_RUN INSTALL KEEP_TMP TRACE"
# Initialise them all to null, set -u friendly ;-)
for opt in $optnames ; do
  eval OPT_$opt=''
done
# Initialise OPT_REPO from env var $REPO:
OPT_REPO="$REPO"
# No default for the processing mode (build/rebuild/update/remove):
PROCMODE=''

while [ $# != 0 ]; do
  case "$1" in
    # we'll accept build/rebuild/update/remove with or without '--'
    build | --build )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='build'
      shift; continue ;;
    rebuild | --rebuild )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='rebuild'
      shift; continue ;;
    update | --update )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='update'
      shift; continue ;;
    remove | --remove )
      [ -n "$PROCMODE" ] && { print_usage; exit_cleanup; exit 3; }
      PROCMODE='remove'
      shift; continue ;;
    --repo=* )
      OPT_REPO=$(echo "$1" | sed 's/^--repo=//')
      shift; continue ;;
    --quiet | -q )
      OPT_QUIET='y'
      shift; continue ;;
    --verbose | -v )
      [ "$OPT_VERBOSE" = 'y' ] && OPT_VERY_VERBOSE='y'
      OPT_VERBOSE='y'
      shift; continue ;;
    --very-verbose | -vv )
      OPT_VERY_VERBOSE='y'
      shift; continue ;;
    --* )
      found='n'
      for opt in $optnames; do
        arg=$(echo $opt | tr '_' '-' | tr '[:upper:]' '[:lower:]')
        if [ "$1" = "--${arg}" -o "$1" = "--${arg}=yes" -o "$1" = "--${arg}=y" ]; then
          eval OPT_${opt}='y'
          found='y'; break
        elif [ "$1" = "--no-${arg}" -o "$1" = "--${arg}=no" -o "$1" = "--${arg}=n" ]; then
          eval OPT_${opt}='n'
          found='y'; break
        fi
      done
      [ "$found" = 'n' ] && echo "$(basename $0): invalid control argument: $1" >&2
      shift; continue ;;
    * )
      break ;;
  esac
done

if [ -z "$PROCMODE" ]; then
  print_usage
  exit_cleanup
  exit 3
elif [ "$PROCMODE" = 'remove' -a $# = 0 ]; then
  # remove mode with no args => do nothing
  echo "Usage: $(basename $0) remove [--repo=ID] item..."
  echo "In remove mode, you *must* specify the items to be removed."
  exit_cleanup
  exit 3
fi

#-------------------------------------------------------------------------------
# Startup
#-------------------------------------------------------------------------------

PIDFILE="/var/run/$(basename $0).pid"
oldpid=$(cat "$PIDFILE" 2>/dev/null)
if [ -z "$oldpid" -o -z "$(pgrep -u root $(basename $0) | grep -v $$)" ]; then
  echo $$ > "$PIDFILE"
else
  echo "$(basename $0): Another instance is already running." >&2
  exit_cleanup
  exit 3
fi

# Ensure ctrl-c (etc) exits the whole thing, not just a random subshell
trap "exit_cleanup; exit 1" SIGINT SIGQUIT SIGTERM

# Get the support functions
for f in /usr/libexec/$(basename $0)/functions.d/*.sh; do
  if [ -x "$f" ]; then
    . "$f"
  fi
done

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------

# Find out about the host system:
# version of Slackware:
[ -f /etc/slackware-version ] || { log_error "/etc/slackware-version not found"; exit_cleanup; exit 4; }
SYS_SLACKVER="$(cat /etc/slackware-version | sed 's/^Slackware //')"
# native arch:
SYS_ARCH=$(uname -m)
# multilib or not:
SYS_MULTILIB='n'
[ "$SYS_ARCH" = 'x86_64' -a -f /etc/profile.d/32dev.sh ] && SYS_MULTILIB='y'
# number of processors:
SYS_NPROC=$(nproc)

# These config vars are prefixed with SR_ to stop SlackBuilds picking them up.
# However, they do NOT have the SR_ prefix in the config files or environment.
varnames="SBREPO PKGREPO SRCREPO \
          HINTDIR QUEUEDIR LOGDIR TMP \
          ARCH TAG PKGTYPE NUMJOBS"
# These config vars don't need to be obfuscated:
genrepnames="USE_GENREPOS REPOSROOT REPOSOWNER REPOSOWNERGPG DL_URL \
             RSS_TITLE RSS_ICON RSS_LINK RSS_CLURL RSS_DESCRIPTION RSS_FEEDMAX RSS_UUID \
             GPGBIN USE_GPGAGENT FOR_SLAPTGET FOLLOW_SYMLINKS REPO_SUBDIRS REPO_EXCLUDES"
initnames="INIT_GITCLONE INIT_GITBRANCH"

# Initialise the SR_variables from the environment:
for envvar in $varnames $initnames $optnames ; do
  srvar="SR_$envvar"
  eval $srvar="${!envvar}"
done

# Read the user config file to get $REPO:
userconf="~/.slackreporc"
if [ -f "$userconf" ]; then
  . "$userconf"
fi
# If we didn't get a repo id from env or cmd line, drop $REPO from the user config file into $OPT_REPO:
[ -z "$OPT_REPO" ] && OPT_REPO="${REPO:-SBo}"
# Read the main repo config file, overriding anything that came from the user config file:
repoconf="/etc/slackrepo/slackrepo_${OPT_REPO}.conf"
if [ -f "$repoconf" ]; then
  . "$repoconf"
else
  echo "Error: repo configuration file not found: $repoconf"; exit_cleanup; exit 2
fi
# Read the user config file again to override everything in the main repo config file.
# (Yes, we're reading it twice, but that's a lot easier than a proper solution)
if [ -f "$userconf" ]; then
  . "$userconf"
fi

# Backfill the SR_ variables from config file variables,
# and unset the config file variables to prevent SlackBuilds from seeing them:
for name in $varnames $initnames ; do
  srvar="SR_$name"
  [ -z "${!srvar}" ] && eval $srvar=\"${!name}\"
  eval unset $name
done
# and do something similar for the OPT_ variables:
for name in $optnames ; do
  optvar="OPT_$name"
  [ -z "${!optvar}" ] && eval $optvar=\"${!name}\"
  eval unset $name
  # simplify anything that looks like a Boolean:
  if   [ "${!optvar}" = '1' -o "${!optvar}" = 'yes' -o "${!optvar}" = 'y' -o "${!optvar}" = 'YES' -o "${!optvar}" = 'Y' ]; then
    eval $optvar='y'
  elif [ "${!optvar}" = '0' -o "${!optvar}" = 'no'  -o "${!optvar}" = 'n' -o "${!optvar}" = 'NO'  -o "${!optvar}" = 'N' -o "${!optvar}" = '' ]; then
    eval $optvar='n'
  fi
done

# Resolve conflicting options:
# --very-verbose implies --verbose
[ "$OPT_VERY_VERBOSE" = 'y' ] && OPT_VERBOSE='y'
# --verbose overrides --quiet
[ "$OPT_VERBOSE" = 'y' ] && OPT_QUIET='n'
# --dry-run overrides --install
[ "$OPT_DRY_RUN" = 'y' ] && OPT_INSTALL='n'

# If SR_NUMJOBS or SR_ARCH not set, work them out and set them explicitly
if [ -z "$SR_NUMJOBS" ]; then
  SR_NUMJOBS="-j$(( $SYS_NPROC + 1 ))"
fi
# setting ARCH breaks lots of SlackBuilds, which is why we do it ;-)
if [ -z "$SR_ARCH" -o "$SR_ARCH" = '%ARCH%' ]; then
  case "$SYS_ARCH" in
    i?86) SR_ARCH='i486' ;;
    arm*) SR_ARCH='arm' ;;
       *) SR_ARCH="$SYS_ARCH" ;;
  esac
fi

# Substitute %REPO%, %SLACKVER% and %ARCH%
for name in $varnames $initnames; do
  srvar="SR_$name"
  eval $srvar=\"$(echo "${!srvar}" | sed -e "s/%REPO%/$OPT_REPO/g" -e "s/%SLACKVER%/$SYS_SLACKVER/g" -e "s/%ARCH%/$SR_ARCH/g")\"
done
for genrepvar in $genrepnames; do
  eval $genrepvar=\"$(echo "${!genrepvar}" | sed -e "s/%REPO%/$OPT_REPO/g" -e "s/%SLACKVER%/$SYS_SLACKVER/g" -e "s/%ARCH%/$SR_ARCH/g")\"
done

# Do this now so we can log the config:
mkdir -p "$SR_LOGDIR"
MAINLOG="$SR_LOGDIR"/$(basename $0)_$(date '+%F_%T').log
> "$MAINLOG"

# Log the config
[ "$OPT_VERBOSE" = 'y' ] && echo ""
log_verbose "Configuration:"
log_verbose "  $PROCMODE"
log_verbose "  --repo=$OPT_REPO"
if [ "$OPT_VERY_VERBOSE" = 'y' ]; then
  log_verbose "  --very-verbose"
elif [ "$OPT_VERBOSE" = 'y' ]; then
  log_verbose "  --verbose"
elif [ "$OPT_QUIET" = 'y' ]; then
  log_verbose "  --quiet"
fi
[ "$OPT_DRY_RUN" = 'y'  ] && log_verbose "  --dry-run"
[ "$OPT_INSTALL" = 'y'  ] && log_verbose "  --install"
[ "$OPT_TEST" = 'y'     ] && log_verbose "  --test"
[ "$OPT_KEEP_TMP" = 'y' ] && log_verbose "  --keep-tmp"
[ "$OPT_TRACE" = 'y'    ] && log_verbose "  --trace"
for name in $varnames; do
  srvar="SR_$name"
  log_verbose "  $name='${!srvar}'"
done
[ "$OPT_VERBOSE" = 'y' ] && echo ""

#-------------------------------------------------------------------------------
# Initialisation
#-------------------------------------------------------------------------------

# Arrays for tracking build outcomes:
declare -a OKLIST SKIPPEDLIST FAILEDLIST ABORTEDLIST

# Temporary directory:
SR_TMP=${SR_TMP:-/tmp/SBo}
# really really don't want the next bit to go badly ;-)
if [ -n "$SR_TMP" -a -d "$SR_TMP" -a "$OPT_KEEP_TMP" != 'y' ]; then
  log_normal "Removing $SR_TMP/* ..."
  rm -rf "${SR_TMP:-dont-tase-me-bro}"/*
else
  mkdir -p $SR_TMP
fi
# We also need a slackrepo-specific temporary directory
MYTMPDIR=$(mktemp -t -d slackrepo.XXXXXX) || { exit_cleanup; exit 4; }

# Disposable package repository for dry run:
if [ "$OPT_DRY_RUN" = 'y' ]; then
  DRYREPO="$MYTMPDIR"/dryrun-packages
  rm -rf "$DRYREPO"
  mkdir -p "$DRYREPO"
fi

# Create directories:
[ -d "$SR_SBREPO" ]   || { log_normal "Creating SlackBuild repository: $SR_SBREPO" ; mkdir -p "$SR_SBREPO"   ; }
[ -d "$SR_SRCREPO" ]  || { log_normal "Creating source repository: $SR_SRCREPO"    ; mkdir -p "$SR_SRCREPO"  ; }
[ -d "$SR_PKGREPO" ]  || { log_normal "Creating package repository: $SR_PKGREPO"   ; mkdir -p "$SR_PKGREPO"  ; }
[ -d "$SR_HINTDIR" ]  || { log_normal "Creating hintfile directory: $SR_HINTDIR"   ; mkdir -p "$SR_HINTDIR"  ; }
[ -d "$SR_QUEUEDIR" ] || { log_normal "Creating queuefile directory: $SR_QUEUEDIR" ; mkdir -p "$SR_QUEUEDIR" ; }
[ -d "$SR_LOGDIR" ]   || { log_normal "Creating log directory: $SR_LOGDIR"         ; mkdir -p "$SR_LOGDIR"   ; }

# Changelog:
CHANGELOG="$SR_PKGREPO"/.changelog
if [ -s "$CHANGELOG" ]; then
  log_normal "Continuing changelog from previous run."
else
  > "$CHANGELOG"
fi

# git stuff for the SlackBuilds repo:
if [ -z "$(ls "$SR_SBREPO" 2>/dev/null)" ]; then
  if [ -n "${SR_INIT_GITCLONE}" ]; then
    log_normal "Cloning SlackBuilds repository $SR_SBREPO from ${SR_INIT_GITCLONE} ..."
    git clone "${SR_INIT_GITCLONE}" "$SR_SBREPO"
    cd "$SR_SBREPO"
    git fetch -a
    git remote update
    mybranch="${SR_INIT_GITBRANCH:-$SYS_SLACKVER}"
    if [ $(git rev-parse --abbrev-ref HEAD) != "$mybranch" ]; then
      git checkout -b "$mybranch" -t origin/"$mybranch"
    fi
    log_normal "Finished cloning SlackBuilds repository."
  fi
elif [ -d $SR_SBREPO/.git ]; then
  cd $SR_SBREPO
  # Is git clean, and is the current branch SBo's stable branch?
  log_normal "Checking git ..."
  muck="$(git status -s .)"
  currbranch=$(git rev-parse --abbrev-ref HEAD)
  if [ -z "$muck" -a "$currbranch" = "$SYS_SLACKVER" ]; then
    if [ -n "$(find "$SR_SBREPO"/.git/FETCH_HEAD -mtime +1 2>/dev/null)" ]; then
      log_normal "Updating git ..."
      if [ "$OPT_QUIET" = 'y' ]; then
        git fetch -a                             >> "$MAINLOG" 2>&1
        git merge --ff-only origin/"$currbranch" >> "$MAINLOG" 2>&1
      else
        git fetch -a                             2>&1 | tee -a "$MAINLOG"
        git merge --ff-only origin/"$currbranch" 2>&1 | tee -a "$MAINLOG"
      fi
      log_normal "Finished updating git."
    fi
  fi
fi

# git: log a summary
GOTGIT='n'
if [ -d "$SR_SBREPO"/.git ]; then
  GOTGIT='y'
  [ -n "$(cd $SR_SBREPO; git status -s .)" ] && dirty=' (DIRTY)'
  [ "$OPT_VERBOSE" = 'y' ] && echo ""
  log_verbose "Git repo:   $SR_SBREPO"
  log_verbose "  branch:   $(git rev-parse --abbrev-ref HEAD)"
  log_verbose "  date:     $(date --date=@$(git log -n 1 --format=%ct))"
  log_verbose "  revision: $(git rev-parse HEAD)$dirty"
  log_verbose "  title:    $(git log -n 1 --format=%s)"
  echo ""
fi

# Warn about already installed packages (using package tag)
if [ -n "$SR_TAG" -a "$OPT_INSTALL" != 'y' -a "$PROCMODE" != 'remove' ]; then
  installed=$(ls /var/log/packages/*"$SR_TAG" 2>/dev/null)
  if [ -n "$installed" ]; then
    for pkg in $installed; do
      pkgnam=$(basename $pkg | rev | cut -f4- -d- | rev)
      log_warning "$(basename $pkg): package is already installed"
    done
  fi
fi

#-------------------------------------------------------------------------------
# Main loop
#-------------------------------------------------------------------------------

if [ $# = 0 ]; then
  if [ "$PROCMODE" = 'update' ]; then
    # update mode with no args => process everything in the package repo
    set -- "$SR_PKGREPO"
  else
    # other modes with no args => process everything in the SlackBuilds repo
    set -- "$SR_SBREPO"
  fi
fi

BLAME="$(basename $0)"
while [ $# != 0 ]; do
  arg="$1"
  shift
  unset PARSEDLIST UNPARSEDLIST
  if [ "$PROCMODE" = 'build' -o "$PROCMODE" = 'rebuild' ]; then
    parse_args -s "$arg"
    [ $? != 0 ] && continue
  else # 'update' or 'remove'
    parse_args -p "$arg"
    [ $? != 0 ] && continue
  fi
  set -- "${UNPARSEDLIST[@]}" "$@"
  # Note that we set the variable $ITEMID (upper case) so that other functions
  # called recursively (which get $itemid as an argument) can test whether they
  # are dealing with the top level item.
  for ITEMID in "${PARSEDLIST[@]}"; do
    log_start "$ITEMID"
    case "$PROCMODE" in
    'build' | 'rebuild' )
      build_with_deps "$ITEMID"
      ;;
    'update' )
      itemdir="${ITEMDIR[$ITEMID]}"
      if [ -d "$SR_SBREPO"/"$itemdir"/ ]; then
        build_with_deps "$ITEMID"
      else
        remove_item "$ITEMID"
      fi
      ;;
    'remove' )
      remove_item "$ITEMID"
      ;;
    *)
      log_error "$(basename $0): Unrecognised PROCMODE = $PROCMODE"
      exit 4
      ;;
    esac
  done
done

#-------------------------------------------------------------------------------
# Print a summary of what happened
#-------------------------------------------------------------------------------

log_start "SUMMARY"
log_always "Logfile:    $MAINLOG"
secs=$(( $(date +%s) - $starttime ))
h=$(( $secs / 3600 )); m=$(( ( $secs / 60) % 60 )); s=$(( $secs % 60 ))
log_normal "Runtime:    ${h}h ${m}m ${s}s"

if [ "$OPT_DRY_RUN" = 'y' ]; then
  OKLIST=( $(printf '%s\n' "${OKLIST[@]}" | sort -u) )
  okcount="${#OKLIST[@]}"
  log_always "Dry run OK: $okcount"
  [ "$OPT_QUIET" != 'y' -a "$okcount" != 0 ] && printf '  %s\n' "${OKLIST[@]}" | tee -a "$MAINLOG"
else
  log_always "Added:      $(grep ': Added'   "$CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Added'   "$CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort | tee -a "$MAINLOG"
  log_always "Updated:    $(grep ': Updated' "$CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Updated' "$CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort | tee -a "$MAINLOG"
  log_always "Rebuilt:    $(grep ': Rebuilt' "$CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Rebuilt' "$CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort | tee -a "$MAINLOG"
  log_always "Removed:    $(grep ': Removed' "$CHANGELOG" | wc -l)"
  [ "$OPT_QUIET" != 'y' ] && \
    grep ': Removed' "$CHANGELOG" | sed -e 's/^/  /' -e 's/:.*//' | sort | tee -a "$MAINLOG"
fi
SKIPPEDLIST=( $(printf '%s\n' "${SKIPPEDLIST[@]}" | sort -u) )
skippedcount="${#SKIPPEDLIST[@]}"
log_always "Skipped:    $skippedcount"
[ "$OPT_QUIET" != 'y' -a "$skippedcount" != 0 ] && printf '  %s\n' "${SKIPPEDLIST[@]}" | tee -a "$MAINLOG"
FAILEDLIST=( $(printf '%s\n' "${FAILEDLIST[@]}" | sort -u) )
failedcount="${#FAILEDLIST[@]}"
log_always "Failed:     $failedcount"
[ "$OPT_QUIET" != 'y' -a "$failedcount" != 0 ]  && printf '  %s\n' "${FAILEDLIST[@]}" | tee -a "$MAINLOG"
ABORTEDLIST=( $(printf '%s\n' "${ABORTEDLIST[@]}" | sort -u) )
abortedcount="${#ABORTEDLIST[@]}"
log_always "Aborted:    $abortedcount"
[ "$OPT_QUIET" != 'y' -a "$abortedcount" != 0 ] && printf '  %s\n' "${ABORTEDLIST[@]}" | tee -a "$MAINLOG"
warningcount=$(grep '^WARNING: ' "$MAINLOG" | sort -u | wc -l)
log_always "Warnings:   $warningcount"
[ "$OPT_QUIET" != 'y' ] && grep '^WARNING: ' "$MAINLOG" | sort -u | sed 's/^WARNING: /  /' | tee -a "$MAINLOG"

#-------------------------------------------------------------------------------
# Package repository maintenance: gen_repos_files.sh
#-------------------------------------------------------------------------------

genrepstat=0
if [ "$OPT_DRY_RUN" != 'y' -a -s "$CHANGELOG" ]; then
  rcfile=~/.genreprc
  [ -f "$rcfile" ] && { set -e; . "$rcfile"; set +e; }
  if [ "$USE_GENREPOS" = 1 ]; then
    log_start "gen_repos_files.sh"
    # 'man sort' says an in-place sort is ok, so let's be lazy :-)
    sort -o "$CHANGELOG" "$CHANGELOG"
    if [ "$RSS_UUID" = '' ]; then
      setrssuuid="RSS_UUID=\"$(uuidgen -t)\""
      log_normal "Note: setting $setrssuuid in $rcfile"
      echo "$setrssuuid" >> "$rcfile"
      eval $setrssuuid
    fi
    set -o pipefail
    REPOSROOT="$REPOSROOT" REPOSOWNER="$REPOSOWNER" REPOSOWNERGPG="$REPOSOWNERGPG" DL_URL="$DL_URL" \
    RSS_TITLE="$RSS_TITLE" RSS_ICON="$RSS_ICON" RSS_LINK="$RSS_LINK" RSS_CLURL="$RSS_CLURL" \
    RSS_DESCRIPTION="$RSS_DESCRIPTION" RSS_FEEDMAX="$RSS_FEEDMAX" RSS_UUID="$RSS_UUID" \
    GPGBIN="$GPGBIN" USE_GPGAGENT="$USE_GPGAGENT" FOR_SLAPTGET="$FOR_SLAPTGET" \
    FOLLOW_SYMLINKS="$FOLLOW_SYMLINKS" REPO_SUBDIRS="$REPO_SUBDIRS" \
    sh /usr/libexec/$(basename $0)/gen_repos_files.sh -l "$CHANGELOG" | tee -a "$MAINLOG"
    genrepstat=$?
    set +o pipefail
    [ "$genrepstat" != 0 ] && log_error "gen_repos_files.sh failed -- changelog retained"
    echo ""
    log_important "Finished gen_repos_files.sh at $(date +%T)"
  fi
fi

#-------------------------------------------------------------------------------

echo ""

[ "$genrepstat" = 0 -a "$OPT_KEEP_TMP" != 'y' ] && rm -f "$CHANGELOG"
[ "$OPT_KEEP_TMP" != 'y' ] && rm -rf "$DRYREPO"
exit_cleanup

exit 0
